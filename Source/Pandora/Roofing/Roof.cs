#region Header
// /*
//  *    2018 - Pandora - Roof.cs
//  */
#endregion

#region References
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;

using TheBox.BoxServer;

// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
// Issue 10 - End
#endregion

namespace TheBox.Roofing
{
	/// <summary>
	///     Describes a roof generated by the user
	/// </summary>
	public class Roof
	{
		private Point m_BasePoint;

		private readonly RoofImage m_RoofImage;

		// Issue 10 - End

		/// <summary>
		///     Occurs when the image for the current roof has been changed and should be redrawn
		/// </summary>
		public event EventHandler RoofImageChanged;

		/// <summary>
		///     Gets the roof image
		/// </summary>
		public Bitmap Image => m_RoofImage.Image;

		/// <summary>
		///     Gets the rectangles currently selected
		/// </summary>
		// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
		public List<RoofRect> Rectangles
		// Issue 10 - End
		{ get; }

		/// <summary>
		///     Gets or sets the tileset used for this roof
		/// </summary>
		public TileSet TileSet { get; set; }

		/// <summary>
		///     Creates a new roof
		/// </summary>
		public Roof()
		{
			// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
			Rectangles = new List<RoofRect>();
			// Issue 10 - End
			m_RoofImage = new RoofImage();
		}

		/// <summary>
		///     Adds a rectangle to the roof
		/// </summary>
		/// <param name="rect">The new rectangle being added</param>
		/// <returns>True if the rectangle has been succesfully added, false otherwise</returns>
		public bool AddRectangle(RoofRect rect)
		{
			if (rect.Rectangle.Height > 0 && rect.Rectangle.Width > 0)
			{
				if ((!rect.Sloped && !rect.GoesUp && (rect.Rectangle.Height % 2 > 0)) ||
					(!rect.Sloped && rect.GoesUp && (rect.Rectangle.Width % 2 > 0)))
				{
					// This rectangle isn't odd wide and itsn't sloped
					if (MessageBox.Show(
							Pandora.Localization.TextProvider["Roofing.NotOddWide"],
							"",
							MessageBoxButtons.YesNo,
							MessageBoxIcon.Question) == DialogResult.No)
					{
						return false;
					}
				}
			}
			else
			{
				_ = MessageBox.Show(Pandora.Localization.TextProvider["Roofing.EmptyRoof"]);
				return false;
			}

			foreach (var rr in Rectangles)
			{
				if (rr.Rectangle.Equals(rect.Rectangle) && rect.GoesUp == rr.GoesUp && rect.Sloped && rr.Sloped)
				{
					_ = MessageBox.Show(Pandora.Localization.TextProvider["Roofing.AlreadyAdded"]);
					return false;
				}
			}

			Rectangles.Add(rect);

			if (!Calculate())
			{
				_ = MessageBox.Show(Pandora.Localization.TextProvider["Roofing.CantAdd"]);
				_ = Rectangles.Remove(rect);
				_ = Calculate();

				return false;
			}
			m_RoofImage.CreateImage();
			return true;
		}

		/// <summary>
		///     Removes the last rectangle in the list
		/// </summary>
		public void RemoveLastRectangle()
		{
			if (Rectangles.Count == 0)
			{
				return;
			}

			Rectangles.RemoveAt(Rectangles.Count - 1);

			_ = Calculate();
			m_RoofImage.CreateImage();
		}

		/// <summary>
		///     Gets the bounds of the roof defined by the current rectangles
		/// </summary>
		private Rectangle RoofBounds
		{
			get
			{
				if (Rectangles.Count == 0)
				{
					return Rectangle.Empty;
				}
				// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
				var temp = Rectangles[0];
				// Issue 10 - End
				var bounds = new Rectangle(temp.Rectangle.Location, temp.Rectangle.Size);

				for (var i = 1; i < Rectangles.Count; i++)
				{
					// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
					var cfr = Rectangles[i];
					// Issue 10 - End

					if (bounds.Left > cfr.Rectangle.Left)
					{
						bounds.X = cfr.Rectangle.X;
					}

					if (bounds.Top > cfr.Rectangle.Top)
					{
						bounds.Y = cfr.Rectangle.Y;
					}

					if (bounds.Right < cfr.Rectangle.Right)
					{
						bounds.Width = cfr.Rectangle.Right - bounds.Left;
					}

					if (bounds.Bottom < cfr.Rectangle.Bottom)
					{
						bounds.Height = cfr.Rectangle.Bottom - bounds.Top;
					}
				}

				return bounds;
			}
		}

		/// <summary>
		///     Calculates the roof
		/// </summary>
		/// <returns>True if a valid roof can be generated from the current set of rectangles</returns>
		private bool Calculate()
		{
			// Clear the roofimage data if needed
			if (m_RoofImage.Data.Count > 0)
			{
				m_RoofImage.Data.Clear();
			}

			// Empty roof is a valid roof
			if (Rectangles.Count == 0)
			{
				return true;
			}

			var bounds = RoofBounds;

			// Maximum supported roof size is 300 x 300
			if (bounds.Width > 300 || bounds.Height > 300)
			{
				return false;
			}

			m_RoofImage.Width = bounds.Width + 3;
			m_RoofImage.Height = bounds.Height + 3;

			// Create the data array
			// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
			m_RoofImage.Data = new List<int>(m_RoofImage.Width * m_RoofImage.Height);
			// Issue 10 - End

			for (var i = 0; i < m_RoofImage.Width * m_RoofImage.Height; i++)
			{
				m_RoofImage.Data.Add(0);
			}

			m_BasePoint = new Point(bounds.X - 1, bounds.Y - 1);

			bounds.X -= m_BasePoint.X;
			bounds.Y -= m_BasePoint.Y;

			foreach (var roofrect in Rectangles)
			{
				var rect = roofrect.Clone() as RoofRect;

				// Shift the rect to our relative coordinates
				var r = rect.Rectangle;

				r.X -= m_BasePoint.X;
				r.Y -= m_BasePoint.Y;

				rect.Rectangle = r;

				if (rect.GoesUp)
				{
					for (var i = 0; i < rect.Rectangle.Height + 1; i++)
					{
						_ = AddVertexX(
							rect.Rectangle.Left,
							rect.Rectangle.Right,
							rect.Rectangle.Top + i,
							rect.Tent ? Math.Min(i + 1, rect.Rectangle.Height + 1 - i) : 1000,
							rect.Sloped ? rect.Slope : Slope.None);
					}
				}
				else
				{
					for (var i = 0; i < rect.Rectangle.Width + 1; i++)
					{
						_ = AddVertexY(
							rect.Rectangle.Top,
							rect.Rectangle.Bottom,
							rect.Rectangle.Left + i,
							rect.Tent ? Math.Min(i + 1, rect.Rectangle.Width + 1 - i) : 1000,
							rect.Sloped ? rect.Slope : Slope.None);
					}
				}
			}

			return true;
		}

		/// <summary>
		///     Adds a vertex to the roof data lying perpendicular to the Y axis of its roof edge
		/// </summary>
		/// <param name="x1">The left x coordinate of the section</param>
		/// <param name="x2">The right x coordinate of the section</param>
		/// <param name="y">The y coordinate of the section</param>
		/// <param name="hLimit">The limit in height for this roof</param>
		/// <param name="slope">The type of slope for this roof</param>
		/// <returns>True if the section has been correctly added</returns>
		private bool AddVertexX(int x1, int x2, int y, int hLimit, Slope slope)
		{
			var added = false;

			var height = 1;

			while (x2 >= x1)
			{
				if (slope == Slope.None || slope == Slope.Right)
				{
					// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
					if (m_RoofImage.Data[x2 + (y * m_RoofImage.Width)] < height)
					// Issue 10 - End
					{
						m_RoofImage.Data[x2 + (y * m_RoofImage.Width)] = height;
						added = true;
					}

					x2--;
				}

				if (slope == Slope.None || slope == Slope.Left)
				{
					// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
					if (m_RoofImage.Data[x1 + (y * m_RoofImage.Width)] < height)
					// Issue 10 - End
					{
						m_RoofImage.Data[x1 + (y * m_RoofImage.Width)] = height;
						added = true;
					}

					x1++;
				}

				if (height < hLimit)
				{
					height++;
				}
			}
			return added;
		}

		/// <summary>
		///     Adds a roof section perpendicular to the X axis
		/// </summary>
		/// <param name="y1">The lower y coordinate</param>
		/// <param name="y2">The upper y coordinate</param>
		/// <param name="x">The x coordinate (fixed)</param>
		/// <param name="hLimit">The height limit for this roof section</param>
		/// <param name="slope">The slope for this section</param>
		/// <returns>True if the section has been added</returns>
		private bool AddVertexY(int y1, int y2, int x, int hLimit, Slope slope)
		{
			var added = false;
			var height = 1;

			while (y2 >= y1)
			{
				if (slope == Slope.None || slope == Slope.Top)
				{
					// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
					if (m_RoofImage.Data[x + (y2 * m_RoofImage.Width)] < height)
					// Issue 10 - End
					{
						m_RoofImage.Data[x + (y2 * m_RoofImage.Width)] = height;
						added = true;
					}

					y2--;
				}

				if (slope == Slope.None || slope == Slope.Bottom)
				{
					// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
					if (m_RoofImage.Data[x + (y1 * m_RoofImage.Width)] < height)
					// Issue 10 - End
					{
						m_RoofImage.Data[x + (y1 * m_RoofImage.Width)] = height;
						added = true;
					}

					y1++;
				}

				if (height < hLimit)
				{
					height++;
				}
			}

			return added;
		}

		/// <summary>
		///     Defines possible values for the classic generation mode
		/// </summary>
		public enum TestMode
		{
			/// <summary>
			///     All the roof is generated right away
			/// </summary>
			NoTest,

			/// <summary>
			///     Only the corner pieces are generated first
			/// </summary>
			Test,

			/// <summary>
			///     After testing, the remaining pieces are generated
			/// </summary>
			Rest
		}

		/// <summary>
		///     Retrieves a portion of the roof image consisting of 3 samples
		/// </summary>
		/// <param name="index">The center sample index for the line</param>
		/// <returns>An array of 3 int values representing the line centered at index</returns>
		private int[] MakeLine(int index)
		{
			var line = new int[3];

			// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
			line[0] = m_RoofImage.Data[index - 1];
			line[1] = m_RoofImage.Data[index];
			line[2] = m_RoofImage.Data[index + 1];
			// Issue 10 - End

			return line;
		}

		/// <summary>
		///     Does classic generation of the roof
		/// </summary>
		/// <param name="mode">The mode for this generation</param>
		/// <param name="height">The height at which the tiling occurs</param>
		/// <param name="hue">The hue for the roof</param>
		/// <returns>True if generation is succesful</returns>
		public bool GenerateClassic(TestMode mode, int height, int hue)
		{
			var roofIDs = new int[m_RoofImage.Width * m_RoofImage.Height];
			var fail = false;

			// Revert any sign changes due to image processing
			for (var i = 0; i < m_RoofImage.Width * m_RoofImage.Height; i++)
			{
				// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
				if (m_RoofImage.Data[i] < 0)
				{
					m_RoofImage.Data[i] = -m_RoofImage.Data[i];
				}
				// Issue 10 - End
			}

			// Calculate the roof ids
			for (var i = 0; i < m_RoofImage.Width * m_RoofImage.Height; i++)
			{
				// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
				if (m_RoofImage.Data[i] == 0)
				// Issue 10 - End
				{
					roofIDs[i] = 0;
				}
				else
				{
					var flags = RoofingHelper.GetFlags(MakeLine(i - m_RoofImage.Width), MakeLine(i), MakeLine(i + m_RoofImage.Width));
					roofIDs[i] = TileSet.FindID(flags);

					if (roofIDs[i] == 0)
					{
						// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
						m_RoofImage.Data[i] = -m_RoofImage.Data[i];
						// Issue 10 - End
						fail = true;
					}

					if (mode != TestMode.NoTest)
					{
						var corner = !((flags & ~0x88878778) != 0) || !((flags & ~0x88887877) != 0) || !((flags & ~0x77878888) != 0) ||
									 !((flags & ~0x87787888) != 0) || !((flags & ~0x87777777) != 0) || !((flags & ~0x77877777) != 0) ||
									 !((flags & ~0x77777877) != 0) || !((flags & ~0x77777778) != 0);

						if (mode == TestMode.Test && !corner)
						{
							roofIDs[i] = 0;
						}

						if (mode == TestMode.Rest && corner)
						{
							roofIDs[i] = 0;
						}
					}
				}
			}

			if (fail)
			{
				m_RoofImage.CreateImage();

				// Request redraw image
				RoofImageChanged?.Invoke(this, new EventArgs());

				if (MessageBox.Show(
						Pandora.Localization.TextProvider["Roofing.MissTiles"],
						"",
						MessageBoxButtons.YesNo,
						MessageBoxIcon.Question) == DialogResult.No)
				{
					return false;
				}
			}

			var idFormat = hue > 0 ? "static {0} set hue " + hue : "static {0}";
			var p = 0;
			for (var y = 0; y < m_RoofImage.Height; y++)
			{
				for (var x = 0; x < m_RoofImage.Width; x++, p++)
				{
					if (roofIDs[p] == 0)
					{
						continue;
					}

					int dx;
					for (dx = 1; dx + x < m_RoofImage.Width; dx++)
					{
						// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
						if ((roofIDs[p + dx] != roofIDs[p]) || (m_RoofImage.Data[p] != m_RoofImage.Data[p + dx]))
						// Issue 10 - End
						{
							break;
						}
					}

					int dy;
					for (dy = 1; dy + y < m_RoofImage.Height; dy++)
					{
						if ((roofIDs[p + (m_RoofImage.Width * dy)] != roofIDs[p]) ||
							// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
							(m_RoofImage.Data[p] != m_RoofImage.Data[p + (m_RoofImage.Width * dy)]))
						// Issue 10 - End
						{
							break;
						}
					}

					dx--;
					dy--;

					// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
					var tilez = height + (3 * m_RoofImage.Data[p]) - 3;
					// Issue 10 - End
					var tileid = roofIDs[p];
					int tilex;
					int tiley;
					int tilew;
					int tileh;
					if (dx > 0 || dy > 0)
					{
						tilex = m_BasePoint.X + x;
						tiley = m_BasePoint.Y + y;

						if (dy > dx)
						{
							tilew = 1;
							tileh = dy + 1;

							while (dy >= 0)
							{
								roofIDs[p + (m_RoofImage.Width * dy)] = 0;
								dy--;
							}
						}
						else
						{
							tilew = dx + 1;
							tileh = 1;

							while (dx >= 0)
							{
								roofIDs[p + dx] = 0;
								dx--;
							}
						}

						x += dx;
						p += dx;
					}
					else
					{
						tilex = m_BasePoint.X + x;
						tiley = m_BasePoint.Y + y;
						tilew = 1;
						tileh = 1;
					}

					// Build command
					var item = String.Format(idFormat, tileid);
					var cmd = String.Format("TileXYZ {0} {1} {2} {3} {4} {5}", tilex, tiley, tilew, tileh, tilez, item);
					Pandora.SendToUO(cmd, true);
				}
			}

			return true;
		}

		/// <summary>
		///     Generates the roof through the boxserver
		/// </summary>
		/// <param name="height">The height at which generation should happen</param>
		/// <param name="hue">The hue for the items</param>
		public void GenerateThroughServer(int height, int hue)
		{
			var roofIDs = new int[m_RoofImage.Width * m_RoofImage.Height];
			var fail = false;

			// Revert any sign changes due to image processing
			for (var i = 0; i < m_RoofImage.Width * m_RoofImage.Height; i++)
			{
				// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
				if (m_RoofImage.Data[i] < 0)
				{
					m_RoofImage.Data[i] = -m_RoofImage.Data[i];
				}
				// Issue 10 - End
			}

			// Calculate the roof ids
			for (var i = 0; i < m_RoofImage.Width * m_RoofImage.Height; i++)
			{
				// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
				if (m_RoofImage.Data[i] == 0)
				// Issue 10 - End
				{
					roofIDs[i] = 0;
				}
				else
				{
					var flags = RoofingHelper.GetFlags(MakeLine(i - m_RoofImage.Width), MakeLine(i), MakeLine(i + m_RoofImage.Width));
					roofIDs[i] = TileSet.FindID(flags);

					if (roofIDs[i] == 0)
					{
						// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
						m_RoofImage.Data[i] = -m_RoofImage.Data[i];
						// Issue 10 - End
						fail = true;
					}
				}
			}

			if (fail)
			{
				m_RoofImage.CreateImage();

				// Request redraw image
				RoofImageChanged?.Invoke(this, new EventArgs());

				if (MessageBox.Show(
						Pandora.Localization.TextProvider["Roofing.MissTiles"],
						"",
						MessageBoxButtons.YesNo,
						MessageBoxIcon.Question) == DialogResult.No)
				{
					return;
				}
			}

			_ = hue > 0 ? "static {0} set hue " + hue : "static {0}";

			var p = 0;

			// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
			var items = new List<BuildItem>();
			// Issue 10 - End

			for (var y = 0; y < m_RoofImage.Height; y++)
			{
				for (var x = 0; x < m_RoofImage.Width; x++, p++)
				{
					if (roofIDs[p] == 0)
					{
						continue;
					}

					// Build item
					var item = new BuildItem
					{
						Hue = hue,
						ID = roofIDs[p],

						X = m_BasePoint.X + x,
						Y = m_BasePoint.Y + y,
						// Issue 10 - Update the code to Net Framework 3.5 - http://code.google.com/p/pandorasbox3/issues/detail?id=10 - Smjert
						Z = height + (3 * m_RoofImage.Data[p]) - 3
					};
					// Issue 10 - End

					items.Add(item);
				}
			}

			var msg = new BuildMessage
			{
				Items = items
			};

			_ = Pandora.BoxConnection.SendToServer(msg);
		}
	}
}